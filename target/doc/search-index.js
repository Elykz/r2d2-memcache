var searchIndex = {};
searchIndex["r2d2_memcache"] = {"doc":"","items":[[0,"connection_info","r2d2_memcache","",null,null],[3,"ConnectionInfo","r2d2_memcache::connection_info","",null,null],[12,"addr","","",0,null],[8,"IntoConnectionInfo","","",null,null],[10,"into_connection_info","","",1,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"into_connection_info","","",0,null],[11,"to_socket_addrs","","",0,null],[0,"error","r2d2_memcache","",null,null],[4,"Error","r2d2_memcache::error","A unified enum of errors by memcache::Connection",null,null],[13,"Other","","A memcache::MemcacheError",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"description","","",2,null],[11,"cause","","",2,null],[0,"connection_manager","r2d2_memcache","",null,null],[3,"MemcacheConnectionManager","r2d2_memcache::connection_manager","",null,null],[11,"fmt","","",3,null],[11,"new","","Creates a new `MemcacheConnectionManager`.",3,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[11,"connect","","",3,null],[11,"is_valid","","",3,null],[11,"has_broken","","",3,null]],"paths":[[3,"ConnectionInfo"],[8,"IntoConnectionInfo"],[4,"Error"],[3,"MemcacheConnectionManager"]]};
searchIndex["r2d2"] = {"doc":"A generic connection pool.","items":[[3,"Config","r2d2","A struct specifying the runtime configuration of a pool.",null,null],[3,"NopErrorHandler","","A `HandleError` implementation which does nothing.",null,null],[3,"LoggingErrorHandler","","A `HandleError` implementation which logs at the error level.",null,null],[3,"NopConnectionCustomizer","","A `CustomizeConnection` which does nothing.",null,null],[3,"Pool","","A generic connection pool.",null,null],[3,"InitializationError","","An error returned by `Pool::new` if it fails to initialize connections.",null,null],[3,"GetTimeout","","An error returned by `Pool::get` if it times out without retrieving a connection.",null,null],[3,"State","","Information about the state of a `Pool`.",null,null],[12,"connections","","The number of connections currently being managed by the pool.",0,null],[12,"idle_connections","","The number of idle connections.",0,null],[3,"PooledConnection","","A smart pointer wrapping a connection.",null,null],[0,"config","","Pool configuration.",null,null],[3,"Builder","r2d2::config","A builder for `Config`.",null,null],[3,"Config","","A struct specifying the runtime configuration of a pool.",null,null],[11,"fmt","","",1,null],[11,"new","","Constructs a new `Builder`.",1,{"inputs":[],"output":{"name":"builder"}}],[11,"pool_size","","Sets `pool_size`.",1,null],[11,"min_idle","","Sets `min_idle`.",1,null],[11,"helper_threads","","Sets `helper_threads`.",1,null],[11,"test_on_check_out","","Sets `test_on_check_out`.",1,null],[11,"initialization_fail_fast","","Sets `initialization_fail_fast`.",1,null],[11,"max_lifetime","","Sets `max_lifetime`.",1,null],[11,"idle_timeout","","Sets `idle_timeout`.",1,null],[11,"connection_timeout","","Sets `connection_timeout` to the specified duration.",1,null],[11,"error_handler","","Sets the `error_handler`.",1,null],[11,"connection_customizer","","Sets the `connection_customizer`.",1,null],[11,"build","","Consumes the `Builder`, turning it into a `Config`.",1,null],[11,"fmt","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"config"}}],[11,"builder","","Creates a new `Builder` which can be used to construct a customized\n`Config`.",2,{"inputs":[],"output":{"name":"builder"}}],[11,"pool_size","","The maximum number of connections managed by the pool.",2,null],[11,"min_idle","","If set, the pool will try to maintain at least this many idle\nconnections at all times, while respecting the value of `pool_size`.",2,null],[11,"helper_threads","","The number of threads that the pool will use for asynchronous\noperations such as connection creation and health checks.",2,null],[11,"test_on_check_out","","If true, the health of a connection will be verified via a call to\n`ConnectionManager::is_valid` before it is checked out of the pool.",2,null],[11,"initialization_fail_fast","","If true, `Pool::new` will synchronously initialize its connections,\nreturning an error if they could not be created.",2,null],[11,"idle_timeout","","If set, connections will be closed after sitting idle for at most 30\nseconds beyond this duration.",2,null],[11,"max_lifetime","","If set, connections will be closed after existing for at most 30 seconds\nbeyond this duration. If a connection reaches its maximum lifetime while\nchecked out it will be closed when it is returned to the pool.",2,null],[11,"connection_timeout","","Calls to `Pool::get` will wait this long for a connection to become\navailable before returning an error.",2,null],[11,"error_handler","","The handler for error reported in the pool.",2,null],[11,"connection_customizer","","The connection customizer used by the pool.",2,null],[8,"ManageConnection","r2d2","A trait which provides connection-specific functionality.",null,null],[16,"Connection","","The connection type this manager deals with.",3,null],[16,"Error","","The error type returned by `Connection`s.",3,null],[10,"connect","","Attempts to create a new connection.",3,null],[10,"is_valid","","Determines if the connection is still connected to the database.",3,null],[10,"has_broken","","*Quickly* determines if the connection is no longer usable.",3,null],[8,"HandleError","","A trait which handles errors reported by the `ManageConnection`.",null,null],[10,"handle_error","","Handles an error.",4,null],[8,"CustomizeConnection","","A trait which allows for customization of connections.",null,null],[11,"on_acquire","","Called with connections immediately after they are returned from\n`ManageConnection::connect`.",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"handle_error","","",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"handle_error","","",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"new","","Creates a new connection pool.",9,{"inputs":[{"name":"config"},{"name":"m"}],"output":{"name":"result"}}],[11,"state","","Returns information about the current state of the pool.",9,null],[11,"config","","Returns the pool&#39;s configuration.",9,null],[11,"get","","Retrieves a connection from the pool.",9,null],[11,"fmt","","",10,null],[11,"fmt","","",10,null],[11,"description","","",10,null],[11,"fmt","","",11,null],[11,"fmt","","",11,null],[11,"description","","",11,null],[11,"fmt","","",0,null],[11,"fmt","","",12,null],[11,"drop","","",12,null],[11,"deref","","",12,null],[11,"deref_mut","","",12,null]],"paths":[[3,"State"],[3,"Builder"],[3,"Config"],[8,"ManageConnection"],[8,"HandleError"],[8,"CustomizeConnection"],[3,"NopErrorHandler"],[3,"LoggingErrorHandler"],[3,"NopConnectionCustomizer"],[3,"Pool"],[3,"InitializationError"],[3,"GetTimeout"],[3,"PooledConnection"]]};
searchIndex["antidote"] = {"doc":"Mutex and RwLock types that do not poison themselves.","items":[[3,"WaitTimeoutResult","antidote","A type indicating whether a timed wait on a condition variable returned\ndue to a time out or not.",null,null],[3,"Mutex","","Like `std::sync::Mutex` except that it does not poison itself.",null,null],[3,"MutexGuard","","Like `std::sync::MutexGuard`.",null,null],[3,"Condvar","","Like `std::sync::Condvar`.",null,null],[3,"TryLockError","","Like `std::sync::TryLockError`.",null,null],[3,"RwLock","","Like `std::sync::RwLock` except that it does not poison itself.",null,null],[3,"RwLockReadGuard","","Like `std::sync::RwLockReadGuard`.",null,null],[3,"RwLockWriteGuard","","Like `std::sync::RwLockWriteGuard`.",null,null],[6,"TryLockResult","","Like `std::sync::TryLockResult`.",null,null],[11,"fmt","","",0,null],[11,"new","","Like `std::sync::Mutex::new`.",0,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"into_inner","","Like `std::sync::Mutex::into_inner`.",0,null],[11,"lock","","Like `std::sync::Mutex::lock`.",0,null],[11,"try_lock","","Like `std::sync::Mutex::try_lock`.",0,null],[11,"get_mut","","Like `std::sync::Mutex::get_mut`.",0,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"new","","Like `std::sync::Condvar::new`.",2,{"inputs":[],"output":{"name":"condvar"}}],[11,"wait","","Like `std::sync::Condvar::wait`.",2,null],[11,"wait_timeout","","Like `std::sync::Condvar::wait_timeout`.",2,null],[11,"notify_one","","Like `std::sync::Condvar::notify_one`.",2,null],[11,"notify_all","","Like `std::sync::Condvar::notify_all`.",2,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"description","","",3,null],[11,"fmt","","",4,null],[11,"new","","Like `std::sync::RwLock::new`.",4,{"inputs":[{"name":"t"}],"output":{"name":"rwlock"}}],[11,"into_inner","","Like `std::sync::RwLock::into_inner`.",4,null],[11,"read","","Like `std::sync::RwLock::read`.",4,null],[11,"try_read","","Like `std::sync::RwLock::try_read`.",4,null],[11,"write","","Like `std::sync::RwLock::write`.",4,null],[11,"try_write","","Like `std::sync::RwLock::try_write`.",4,null],[11,"get_mut","","Like `std::sync::RwLock::get_mut`.",4,null],[11,"deref","","",5,null],[11,"deref","","",6,null],[11,"deref_mut","","",6,null],[11,"timed_out","","Returns whether the wait was known to have timed out.",7,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null]],"paths":[[3,"Mutex"],[3,"MutexGuard"],[3,"Condvar"],[3,"TryLockError"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"WaitTimeoutResult"]]};
searchIndex["memcache"] = {"doc":"rust-memcache is a [Memcached](https://memcached.org/) client written in pure rust.","items":[[3,"Connection","memcache","The connection acts as a TCP connection to the memcached server",null,null],[3,"Options","","",null,null],[12,"no_reply","","",0,null],[12,"exptime","","",0,null],[12,"flags","","",0,null],[4,"MemcacheError","","Stands for errors raised from rust-memcache",null,null],[13,"Io","","`std::io` related errors.",1,null],[13,"FromUtf8","","Error raised when unserialize value data which from memcached to String",1,null],[13,"Error","","Unknown error raised by memcached, [more detail](https://github.com/memcached/memcached/blob/master/doc/protocol.txt#L99-L101).",1,null],[13,"ClientError","","Client side error raised by memcached, probably caused by invalid input, [more detail](https://github.com/memcached/memcached/blob/master/doc/protocol.txt#L103-L107).",1,null],[13,"ServerError","","Server side error raise by memcached, [more detail](https://github.com/memcached/memcached/blob/master/doc/protocol.txt#L109-L116).",1,null],[11,"fmt","","",2,null],[11,"connect","","connect to the memcached server.",2,{"inputs":[{"name":"a"}],"output":{"name":"result"}}],[11,"flush","","",2,null],[11,"set","","",2,null],[11,"set_with_options","","",2,null],[11,"add","","",2,null],[11,"add_with_options","","",2,null],[11,"replace","","",2,null],[11,"replace_with_options","","",2,null],[11,"append","","",2,null],[11,"append_with_options","","",2,null],[11,"prepend","","",2,null],[11,"prepend_with_options","","",2,null],[11,"get","","",2,null],[11,"delete","","",2,null],[11,"incr","","",2,null],[11,"decr","","decrement the value of memcached",2,null],[11,"version","","get the memcached server version",2,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"description","","",1,null],[11,"cause","","",1,null],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"memcacheerror"}}],[11,"from","","",1,{"inputs":[{"name":"fromutf8error"}],"output":{"name":"memcacheerror"}}],[11,"from","","",1,{"inputs":[{"name":"string"}],"output":{"name":"memcacheerror"}}],[11,"fmt","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"options"}}],[8,"ToMemcacheValue","","determine how the value is serialize to memcache",null,null],[10,"get_flags","","",3,null],[10,"get_exptime","","",3,null],[10,"get_length","","",3,null],[10,"write_to","","",3,null],[8,"FromMemcacheValue","","determine how the value is unserialize to memcache",null,null],[10,"from_memcache_value","","",4,{"inputs":[{"name":"vec"},{"name":"u16"}],"output":{"name":"result"}}]],"paths":[[3,"Options"],[4,"MemcacheError"],[3,"Connection"],[8,"ToMemcacheValue"],[8,"FromMemcacheValue"]]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The &quot;payload&quot; of a log message.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level\nfilter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has\nalready been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",0,null],[13,"Warn","","The &quot;warn&quot; level.",0,null],[13,"Info","","The &quot;info&quot; level.",0,null],[13,"Debug","","The &quot;debug&quot; level.",0,null],[13,"Trace","","The &quot;trace&quot; level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging\nframework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger","","Sets the global logger.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be\nlogged.",2,null],[10,"log","","Logs the `LogRecord`.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,null],[11,"args","","The message body.",3,null],[11,"metadata","","Metadata about the log directive.",3,null],[11,"location","","The location of the log directive.",3,null],[11,"level","","The verbosity level of the message.",3,null],[11,"target","","The name of the target of the directive.",3,null],[11,"level","","The verbosity level of the message.",4,null],[11,"target","","The name of the target of the directive.",4,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"module_path","","The module path of the message.",5,null],[11,"file","","The source file containing the message.",5,null],[11,"line","","The line containing the message.",5,null],[11,"fmt","","",6,null],[11,"get","","Gets the current maximum log level filter.",6,null],[11,"set","","Sets the maximum log level.",6,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"description","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"description","","",8,null],[14,"log","","The standard logging macro.",null,null],[14,"error","","Logs a message at the error level.",null,null],[14,"warn","","Logs a message at the warn level.",null,null],[14,"info","","Logs a message at the info level.",null,null],[14,"debug","","Logs a message at the debug level.",null,null],[14,"trace","","Logs a message at the trace level.",null,null],[14,"log_enabled","","Determines if a message logged at the specified level in that module will\nbe logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
initSearch(searchIndex);
